name: Publish Release

on:
  push:
    branches:
      - main

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  
jobs:
  publish-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Gather Release Type
        id: gather-release-type
        run: |
          # Extract the commit message from the most recent commit
          COMMIT_MESSAGE=$(git log --format=%B -n 1)

          # Check for release type labels in the commit message
          if [[ $COMMIT_MESSAGE == *"[major]"* ]]; then
            RELEASE_TYPE="MAJOR"
          elif [[ $COMMIT_MESSAGE == *"[minor]"* ]]; then
            RELEASE_TYPE="MINOR"
          elif [[ $COMMIT_MESSAGE == *"[patch]"* ]]; then
            RELEASE_TYPE="PATCH"
          else
            # Handle cases where no release type is specified
            RELEASE_TYPE="PATCH" # or set a default
          fi

          echo "Release type is: $RELEASE_TYPE"
          echo "release-type=$RELEASE_TYPE" >> $GITHUB_OUTPUT

      - name: Get latest version tag
        id: get-latest-tag
        run: |
          CURRENT_VERSION=$(git describe --abbrev=0 --tags)
          echo "Current version is: $CURRENT_VERSION"
          echo "current-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

      - name: Generate New Version
        id: generate-new-version
        env:
          CURRENT_VERSION: ${{ steps.get-latest-tag.outputs.current-version }}
          RELEASE_TYPE: ${{ steps.gather-release-type.outputs.current-version }}
        run: |
          # Increment the version based on the release type
          if [ "$RELEASE_TYPE" == "MAJOR" ]; then
            IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
            NEW_VERSION="${VERSION_PARTS[0]}.$((${VERSION_PARTS[1]} + 1)).0"
          elif [ "$RELEASE_TYPE" == "MINOR" ]; then
            IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
            NEW_VERSION="${VERSION_PARTS[0]}.$((${VERSION_PARTS[1]} + 1)).${VERSION_PARTS[2]}"
          else
            IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
            NEW_VERSION="${VERSION_PARTS[0]}.${VERSION_PARTS[1]}.$((${VERSION_PARTS[2]} + 1))"
          fi

          echo "New version is: $NEW_VERSION"
          echo "new-version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "current-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

      - name: Set up Git
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"
  
      - uses: actions/checkout@v3
      - uses: ncipollo/release-action@v1
        with:
          commit: ${{ github.sha }}
          tag: ${{ steps.generate-new-version.outputs.new-version }}

      - name: Increment Version and Retag
        env:
          NEW_VERSION: ${{ steps.generate-new-version.outputs.new-version }}
          DEV_IMAGE_TAG: ${{ github.sha }}
        run: |
          # Retag the images with the new version
          docker tag $REGISTRY/${IMAGE_NAME,,}:$DEV_IMAGE_TAG $REGISTRY/${IMAGE_NAME,,}:$NEW_VERSION
          docker tag $REGISTRY/${IMAGE_NAME,,}:$DEV_IMAGE_TAG $REGISTRY/${IMAGE_NAME,,}:latest
      
          # Push the retagged images to the public registry
          docker push $REGISTRY/${IMAGE_NAME,,}:$NEW_VERSION
          docker push $REGISTRY/${IMAGE_NAME,,}:latest